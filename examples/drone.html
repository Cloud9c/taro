<!DOCTYPE html>
<html lang='en'>
	<head>
		<meta charset='UTF-8' />
		<meta name='viewport' content='width=device-width,initial-scale=1' />
		<title>Drone</title>
		<link rel="shortcut icon" href="../files/favicon.ico" />
		<link rel="stylesheet" href="examples.css" />
	</head>
	<body>
		<canvas id='canvas'></canvas>
		<script type='module'>
			import * as TARO from '../build/taro.module.js';
			import { OrbitControls } from './js/OrbitControls.js';

			// app setup
			let entity, geo, mat, mesh;

			const app = new TARO.App({
				canvas: document.getElementById('canvas'),
				antialias: true
			});
			const scene = new TARO.Scene();
			app.setScene(scene);
			scene.background = new TARO.Color( 0xe0e0e0 );

			// lighting
			entity = new TARO.Entity();
			entity.addComponent('light', {type: 'hemisphere', intensity: 0.6});
			entity.position.set(0, 100, 0);

			entity = new TARO.Entity();
			entity.addComponent('light', {type: 'directional'});
			entity.position.set(-100, 175, 100);

			// skybox
			const loader = new TARO.TextureLoader();

			// load a resource
			const texture = loader.load('textures/terrain.jpg', ( texture ) => {
				const textureEquirect = new TARO.WebGLCubeRenderTarget( texture.image.height );
				textureEquirect.fromEquirectangularTexture( app.renderer, texture );
				scene.background = textureEquirect.texture;
			});

			// camera
			entity = new TARO.Entity('camera');
			const camera = entity.addComponent('camera').ref;
			camera.position.set(0.5, 0.5, 0.5);
			const controls = new OrbitControls( camera, app.renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;

			// drone constants
			const mass = 1.380;
			const gravity = 9.80665;
			const defaultRotorForce = mass*gravity/4;
			const dragCoefficient = 6;
			const angularDragCoefficient = 0.01;

			// components
			TARO.registerComponent('droneControls', class {

				init() {
					this.rigidbody = this.entity.getComponent('rigidbody').ref;
					this.fl = new TARO.Vec3();
					this.fr = new TARO.Vec3();
					this.bl = new TARO.Vec3();
					this.br = new TARO.Vec3();
					this.drag = new TARO.Vec3();
					this.vector = new TARO.Vec3();

					const parts = this.entity.getComponent('renderable').ref.children;
					this.fans = [parts[30], parts[31], parts[32], parts[33]];

				}

				update( delta ) {

					const rotation = delta * 40;

					this.fans[0].rotateZ( rotation );
					this.fans[1].rotateZ( -rotation );
					this.fans[2].rotateZ( rotation );
					this.fans[3].rotateZ( -rotation );

				}

				fixedUpdate() {

					const input = this.app.input;

					this.fl.set(0, defaultRotorForce, 0);
					this.fr.set(0, defaultRotorForce, 0);
					this.bl.set(0, defaultRotorForce, 0);
					this.br.set(0, defaultRotorForce, 0);

					// throttle up
					if (input.getKey('KeyW')) {
						this.fl.y *= 1.1;
						this.fr.y *= 1.1;
						this.bl.y *= 1.1;
						this.br.y *= 1.1;
					}

					// throttle down
					if (input.getKey('KeyS')) {
						this.fl.y /= 1.1;
						this.fr.y /= 1.1;
						this.bl.y /= 1.1;
						this.br.y /= 1.1;
					}

					// yaw left
					if (input.getKey('KeyA')) {
						this.rigidbody.applyTorque(this.vector.set(0, 0.1, 0));
					}

					// yaw right
					if (input.getKey('KeyD')) {
						this.rigidbody.applyTorque(this.vector.set(0, -0.1, 0));
					}

					// pitch up
					if (input.getKey('KeyI')) {
						this.fl.y /= 1.1;
						this.fr.y /= 1.1;
						this.bl.y *= 1.1;
						this.br.y *= 1.1;	
					}

					// pitch down
					if (input.getKey('KeyK')) {
						this.fl.y *= 1.1;
						this.fr.y *= 1.1;
						this.bl.y /= 1.1;
						this.br.y /= 1.1;
					}

					// roll left
					if (input.getKey('KeyJ')) {
						this.fl.y /= 1.1;
						this.fr.y *= 1.1;
						this.bl.y /= 1.1;
						this.br.y *= 1.1;
					}

					// roll right
					if (input.getKey('KeyL')) {
						this.fl.y *= 1.1;
						this.fr.y /= 1.1;
						this.bl.y *= 1.1;
						this.br.y /= 1.1;
					}

					this.vector.set(0.08483705296, 0, 0.12714576065);
					this.rigidbody.quaternion.vmult(this.vector, this.vector);
					this.rigidbody.quaternion.vmult(this.fl, this.fl);
					this.rigidbody.quaternion.vmult(this.fr, this.fr);
					this.rigidbody.quaternion.vmult(this.bl, this.bl);
					this.rigidbody.quaternion.vmult(this.br, this.br);

					this.rigidbody.applyForce( this.fl, this.vector );
					this.vector.x *= -1;
					this.rigidbody.applyForce( this.fr, this.vector );
					this.vector.x *= -1;
					this.vector.z *= -1;
					this.rigidbody.applyForce( this.bl, this.vector );
					this.vector.x *= -1;
					this.rigidbody.applyForce( this.br, this.vector );

					console.log(this.rigidbody.force)

					// drag force
					const speed = this.rigidbody.velocity.length();
					this.drag.copy(this.rigidbody.velocity).normalize()
					this.drag.scale(-1, this.drag);
					this.drag.scale(dragCoefficient * Math.pow(speed, 2), this.drag);
					this.rigidbody.applyForce( this.drag );

					// torque drag force
					const angularSpeed = this.rigidbody.angularVelocity.length();
					this.drag.copy(this.rigidbody.angularVelocity).normalize()
					this.drag.scale(-1, this.drag);
					this.drag.scale(angularDragCoefficient * Math.pow(angularSpeed, 2), this.drag);
					this.rigidbody.applyTorque( this.drag );

				}

			});

			TARO.registerComponent('followDrone', class FollowDrone {

				init() {
					this.drone = scene.getEntityByName('drone');
					this.oldPosition = new TARO.Vector3();
					this.newPosition = new TARO.Vector3();
					this.offset = new TARO.Vector3();
				}

				update( delta ) {

					// this.newPosition.copy(this.drone.position);
					// this.offset.subVectors(this.newPosition, this.oldPosition);

					// entity.position.add(this.offset);
					// controls.update();

					// this.oldPosition.copy(this.newPosition);
				}

			});

			const objectLoader = new TARO.ObjectLoader();
			objectLoader.load( "models/drone.json", ( obj ) => {

					// drone
					obj.scale.multiplyScalar(0.00271157519);

					const drone = new TARO.Entity('drone');
					drone.addComponent('renderable', obj);
					drone.addComponent('rigidbody', {
						type: 'dynamic',
						mass: mass
					})
					drone.addComponent('shape', {
						type: 'box',
						halfExtents: new TARO.Vector3(0.14475, 0.098, 0.14475)
					})
					drone.addComponent('droneControls')

					entity.addComponent('followDrone');

					controls.target = entity.position;
					controls.update();

				}
			);

			// start the app
			app.start();

		</script>
	</body>
</html>
